/*
  # Fix regenerate_slots_for_date function

  1. Bug Fix
    - Changed slot `end_time` calculation from using service duration to using slot_interval_minutes
    - Previously used `v_duration` (from booking_services.duration_minutes = 60) causing inconsistent slot sizes
    - Now uses `v_slot_interval` (from working hours config) to match the initial slot generation function
    - This ensures slots generated by admin "Save & Regenerate" match the original auto-generated slots

  2. Important Notes
    - The `generate_availability_slots_auto` function already uses slot_interval for end_time
    - This fix aligns `regenerate_slots_for_date` with the same logic
    - Existing booked slots are preserved and not affected
*/

CREATE OR REPLACE FUNCTION regenerate_slots_for_date(
  p_service_id uuid,
  p_date date
)
RETURNS TABLE(slots_created integer, slots_preserved integer)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_start_time time;
  v_end_time time;
  v_last_appointment_time time;
  v_slot_interval integer;
  v_is_active boolean;
  v_break_times jsonb;
  v_is_holiday boolean;
  v_current_time time;
  v_slots_created integer := 0;
  v_slots_preserved integer := 0;
  v_break_start time;
  v_break_end time;
  v_is_in_break boolean;
  v_break_period jsonb;
BEGIN
  SELECT * INTO v_start_time, v_end_time, v_last_appointment_time, v_slot_interval, v_is_active, v_break_times, v_is_holiday
  FROM get_effective_working_hours(p_date);

  IF NOT FOUND OR NOT v_is_active OR v_is_holiday THEN
    DELETE FROM availability_slots
    WHERE service_id = p_service_id
      AND date = p_date
      AND NOT EXISTS (
        SELECT 1 FROM wakala_applications
        WHERE wakala_applications.slot_id = availability_slots.id
      )
      AND NOT EXISTS (
        SELECT 1 FROM bookings
        WHERE bookings.slot_id = availability_slots.id
      );

    RETURN QUERY SELECT 0, 0;
    RETURN;
  END IF;

  SELECT COUNT(*) INTO v_slots_preserved
  FROM availability_slots
  WHERE service_id = p_service_id
    AND date = p_date
    AND (
      EXISTS (
        SELECT 1 FROM wakala_applications
        WHERE wakala_applications.slot_id = availability_slots.id
      )
      OR EXISTS (
        SELECT 1 FROM bookings
        WHERE bookings.slot_id = availability_slots.id
      )
    );

  DELETE FROM availability_slots
  WHERE service_id = p_service_id
    AND date = p_date
    AND NOT EXISTS (
      SELECT 1 FROM wakala_applications
      WHERE wakala_applications.slot_id = availability_slots.id
    )
    AND NOT EXISTS (
      SELECT 1 FROM bookings
      WHERE bookings.slot_id = availability_slots.id
    );

  v_current_time := v_start_time;
  WHILE v_current_time <= v_last_appointment_time LOOP
    v_is_in_break := false;

    IF v_break_times IS NOT NULL AND jsonb_array_length(v_break_times) > 0 THEN
      FOR v_break_period IN SELECT * FROM jsonb_array_elements(v_break_times)
      LOOP
        v_break_start := (v_break_period->>'start')::time;
        v_break_end := (v_break_period->>'end')::time;

        IF v_current_time >= v_break_start AND v_current_time < v_break_end THEN
          v_is_in_break := true;
          EXIT;
        END IF;
      END LOOP;
    END IF;

    IF NOT v_is_in_break AND NOT EXISTS (
      SELECT 1 FROM availability_slots
      WHERE service_id = p_service_id
        AND date = p_date
        AND start_time = v_current_time
    ) THEN
      INSERT INTO availability_slots (service_id, date, start_time, end_time, is_available)
      VALUES (
        p_service_id,
        p_date,
        v_current_time,
        v_current_time + (v_slot_interval || ' minutes')::interval,
        true
      );
      v_slots_created := v_slots_created + 1;
    END IF;

    v_current_time := v_current_time + (v_slot_interval || ' minutes')::interval;
  END LOOP;

  RETURN QUERY SELECT v_slots_created, v_slots_preserved;
END;
$$;
